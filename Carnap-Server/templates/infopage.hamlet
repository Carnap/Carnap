<div#carnap-info-head>
    <div.container>
        <h1>About Carnap

<div#main.container>

    <nav#toc>
        <ul.list-unstyled>
            <li>
                <a href=#what> What is Carnap?
            <li>
                <a href=#why> What's Carnap for?
            <li>
                <a href=#name>Why "Carnap"?
            <li>
                <a href=#how>How does Carnap Work?
            <li>
                <a href=#usage>How can I use Carnap?
            <li>
                <a href=#contributing>How can I get involved?

    <blockquote>
        <p> “The acceptance or rejection of abstract linguistic forms, just as the acceptance or rejection of any other linguistic forms in any branch of science, will finally be decided by their efficiency as instruments, the ratio of the results achieved to the amount and complexity of the efforts required. To decree dogmatic prohibitions of certain linguistic forms instead of testing them by their success or failure in practical use, is worse than futile; it is positively harmful because it may obstruct scientific progress.

        <p> Let us grant to those who work in any special field of investigation the freedom to use any form of expression which seems useful to them; the work in the field will sooner or later lead to the elimination of those forms which have no useful function. Let us be cautious in making assertions and critical in examining them, but tolerant in permitting linguistic forms.”

        <footer>Rudolph Carnap,
            <cite title="Empiricism Semantics and Ontology"> Empiricism Semantics and Ontology


    <section#what>
        <p>Carnap is a free and open-source Haskell framework for creating and exploring formal languages, logics, and semantics. It lets you quickly and straightforwardly define languages, construct logics for those languages, and stipluate their semantics. Carnap then uses your specifications to figure out how to check proofs in a variety of formal systems using your logic, how to find the meanings of compound expressions, and a whole lot more.

        <div#demos.hidden>

            <h2> Demos

            <p> Here are some quick examples of what Carnap can do.

            <div#demo-slider>

                <div.demo>
                    <p> This is a proofbox with a Kalish and Montegue System for Propositional Logic

                    ^{proofcheck 1 "proofchecker Demo" "P:|-:P" ded1}

                <div.demo>
                    <p> This is a proofbox with a Kalish and Montegue System for First-Order Logic

                    ^{proofcheck 2 "proofchecker firstOrder Demo" "AxF(x):|-:F(c)" ""}

                <div.demo>

                    <p> This is a proofbox with a Kalish and Montegue System for Second-Order Logic, with a predicate abstraction rule.

                    ^{proofcheck 3 "proofchecker secondOrder Demo" ":|-: EXAx(F(x) /\\ G(x) <-> X(x))" ded3}

                <div.demo>

                    <p> This is a proofbox with a Fitch system, using rules from <i>the Logic Book</i>, and visually rendering the proof structure.

                    ^{proofcheck 4 "proofchecker LogicBook Demo" ":|-:(((P->Q)->P)->P)" ded2}

            <div#demo-selector>
                <span#demo-left>〈
                <span#demo-num>1
                /
                <span#demo-tot>n
                <span#demo-right>〉

    <section#why>
        <h2>What's Carnap for?

        <p>Carnap is intended for use by educators, students, and researchers working on logic. Carnap makes it possible for educators to create interactive exercises and teaching materials, and for students to get quick and helpful feedback as they learn semantic and syntactic methods for determining what follows from what. Carnap also enables researchers interested in unorthodox formal systems to rapidly prototype proof-checking and semantic tools for computer-assisted logical investigation.

    <section#name>
        <h2>Why "Carnap"?

        <p>Carnap is named after Rudolf Carnap, the philosopher quoted above.

        <p>Carnap (the philosopher) famously advocated a tolerant and experimental approach to logic. Carnap (the program) is pluralistic by design. Inference rules are specified declaratively, making it easy to add new logics to those already provided for a given language. The algorithms for checking whether inferences are correct are applicable to a wide variety of languages, making it easy to introduce new languages.

        <p>Carnap (the philosopher) also had a lot to say about logical types, and how ignoring them can leave you with beliefs that don’t work very well. Carnap (the program) is written in Haskell, a statically-typed functional programming language that uses a theory of logical types to ensure code correctness.

    <section#how>
        <h2>How does Carnap work?

        <p>There are a couple of different tricks involved. But basically, Haskell's type system makes it possible to represent different lexical categories as datatypes, to combine these lexical category datatypes into a larger datatype representing a lexicon (using something like the method described in <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.101.4131">this paper</a>), and to define a language as the result of applying different elements of a lexicon to one another in a grammatical way.

        <p>The upshot is that, using Carnap, you can define a language as the result of snapping together predefined lexical categories. Thanks to Haskell's typeclasses, your languages will inherit various useful properties that their constituent lexical categories carry along with them (for example, languages that contain the lexical category for boolean connectives will automatically know how to parse and display the symbol for "and", or how to compute the semantic value of a conjunction from the semantic values of its conjuncts). And, thanks to Haskell's static typing and the trick of representing lexical categories as types, you're guaranteed that any programming mistake potentially resulting in an ungrammatical expression will be detected when you try to compile the program.

        <p>By representing a large class of languages uniformly (as the result of snapping together lexical categories), we also end up being able to handle them uniformly. In particular, we can use entirely generic algorithms for things like variable substitution, semantic evaluation, β-normalization, higher-order unification... all the good stuff that you need in order to, for example, check proofs for correctness using only a list of acceptable inference rules. As a result, we only need to write code for these algorithms once, and it can automatically be applied to any language that can be defined in the Carnap framework.

        <p>So that's the gist of it. If you'd like to learn more about the details, you can inspect the code, talk to a developer, or read the documentation.

    <section#usage>
        <h2>How can I use Carnap?

        <p>At the moment, the main application for Carnap is to create interactive logic webapps<span class="hidden">, like the ones you see above</span>. Webapps for Carnap can be be written in pure Haskell, and translated into JavaScript using the GHCJS compiler. Or, you can write a front-end in JavaScript and pass proofs to Carnap as JSON for verification.

        <p>The webapps already written using Carnap should be easy to include in websites. Since they're written in pure JavaScript, all you have to do is include the relevant JavaScript file, and indicate in your HTML where you want the interactive widgets to go. You can even use Carnap without doing any coding at all; Carnap integrates with John McFarlane's <a href="pandoc.org">pandoc</a>. So you can transform documents written in pandoc markdown into interactive websites and lecture slides. In fact, the <a href="@{BookR}">Carnap Book</a> was written in this way.

        <p>Carnap also powers the course website for Kansas State University's <i>Introduction to Symbolic Logic I</i>, allowing instructors to write problem sets in pandoc, handling the grading, and allowing students to build up a repetoire of derived rules and lemmas that they can use in their work. If you're interested in teaching your own logic class using Carnap, please don't hesitate to get in touch.

        <p>Other applications (including a command-line tool for proof-checking, and a standalone desktop application) are in the works.

    <section#contributing>
        <h2>How can I get involved?

        <p>If you’d like to support Carnap, please consider starring us on github. If you have suggestions, feature requests, or bug-reports, you can create an issue on github. For general questions, or if you'd like to use Carnap in a class you're teaching, just get in touch on gitter, on irc, or over <a href="mailto:gleachkr@gmail.com">email</a>.

        <p>If you’d like to contribute some code to the project—anything from a new unification algorithm to a css tweak or pandoc template—just put in a pull request!
