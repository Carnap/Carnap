<div.jumbotron.jumbotron-fluod>
    <div.container>
        <h1.display-4>About Carnap

<div#main.container>

    <nav#toc.hidden-sm-down>
        <ul.list-unstyled>
            <li>
                <a href=#what> What is Carnap?
            <li>
                <a href=#why> What's Carnap for?
            <li>
                <a href=#name>Why “Carnap”?
            <li>
                <a href=#how>How does Carnap Work?
            <li>
                <a href=#usage>How can I use Carnap?
            <li>
                <a href=#contributing>How can I get involved?

    <blockquote.blockquote>
        <p> “The acceptance or rejection of abstract linguistic forms, just as
            \ the acceptance or rejection of any other linguistic forms in any branch
            \ of science, will finally be decided by their efficiency as instruments,
            \ the ratio of the results achieved to the amount and complexity of the
            \ efforts required. To decree dogmatic prohibitions of certain linguistic
            \ forms instead of testing them by their success or failure in practical
            \ use, is worse than futile; it is positively harmful because it may
            \ obstruct scientific progress.

        <p> Let us grant to those who work in any special field of
            \ investigation the freedom to use any form of expression which seems
            \ useful to them; the work in the field will sooner or later lead to the
            \ elimination of those forms which have no useful function. Let us be
            \ cautious in making assertions and critical in examining them, but
            \ tolerant in permitting linguistic forms.”

        <footer.blockquote-footer>Rudolph Carnap,
            <cite title="Empiricism Semantics and Ontology"> Empiricism Semantics and Ontology


    <section#what>
        <p> Carnap is a free and open-source Haskell framework for creating and
            \ exploring formal languages, logics, and semantics. It lets you quickly
            \ and straightforwardly define languages, construct logics for those
            \ languages, and stipulate their semantics. Carnap then uses your
            \ specifications to figure out how to check proofs in a variety of formal
            \ systems using your logic, how to find the meanings of compound
            \ expressions, and a whole lot more.

        <div#demos.hidden>

            <h2> Demos

            <p> Here are some quick examples of what Carnap can do.

            <div#demo-slider>

                <div.demo>
                    <p>This is a proofbox with a Kalish and Montague System
                       \ for Propositional Logic. You can directly manipulate the
                       \ proof by typing in the proofbox, and see the effects of
                       \ your changes by mousing over the line-decorations on the
                       \ right hand side.

                    ^{proofcheck 1 "prop" "" ":|-:P\\/-P" aristotleTheorem}

                <div.demo>
                    <p>This is a rendering proofbox with a Kalish and Montague
                       \ System for Propositional Logic, which also visually
                       \ displays the structure of the proof being developed.

                    ^{proofcheck 2 "prop" "render" ":|-:P\\/-P" aristotleTheorem}


                <div.demo>

                    <p> This is a rendering proofbox with Hardegree's variation
                        \ on a Montague system.

                    ^{proofcheck 3 "hardegreeSL" "render" "P/\\Q->R:|-: P->(Q->R)" adjunctionTheorem}

                <div.demo>

                    <p>This is a proofbox with a Fitch system, using rules from #
                       <i>the Logic Book
                       \ and visually rendering the proof structure in the Fitch style.

                    ^{proofcheck 4 "LogicBook" "render" ":|-:(((P->Q)->P)->P)" pierceTheorem}


                <div.demo>
                    <p>This is a proofbox with a Kalish and Montague System
                       \ for First-Order Logic, displaying a proof of Russell's
                       \ Theorem.

                    ^{proofcheck 5 "firstOrder" "render" ":|-:-ExAy(-F(y,y) <-> F(x,y))" russellTheorem}

                <div.demo>
                    <p> Here’s a proof of the fact that the bisectors of the
                        \ sides of a triangle always meet at a point (from the
                        \ assumption that a point is on the bisector of a segment if
                        \ and only if it’s equidistant from the endpoints of that
                        \ segment). ‟F(x,y)” abbreviates that ‟x is on y“, ‟g(y,z)”
                        \ abbreviates ‟the bisector of the segment given by y and z”,
                        \ and ‟h(x,z)” abbreviates ‟the distance from x to z”.
                    <p> (Because of the number of variables, this one may take
                        \ a moment to load initially. Once loaded, it should
                        \ respond quickly to changes.)
                    ^{proofcheck 6 "firstOrder" "render" "AxAyAz(F(x,g(y,z)) ↔ h(x,y) = h(x,z)) :|-: AwAxAyAz(F(w,g(x,y))^F(w,g(x,z))→F(w,g(y,z)))" bisectorTheorem}

                <div.demo>

                    <p> Here are two more proofs of Russell's theorem, this
                        \ time using a version of system QL,
                        \ from P.D. Magnus' free and open textbook #
                        <a href="https://www.fecundity.com/logic/">Forall x,
                        \ and the system FOL from the #
                        <a href="https://github.com/rzach/forallx-yyc">Calgary remix
                        \ of #
                        <i>Forall x.
                        \ Note that we've
                        \ changed how formulas are parsed (dropping the parentheses around
                        \ the arguments to predicates), to match the display
                        \ style of #
                        <i>Forall x.

                    ^{proofcheck 7 "magnusQL" "render" ":|-:-ExAy(-F(y,y) <-> F(x,y))" russellTheoremForallx}

                    ^{proofcheck 8 "thomasBolducAndZachFOL" "render" ":|-:-ExAy(-F(y,y) <-> F(x,y))" russellTheoremCalgary}
                <div.demo>

                    <p> This is a proofbox with a Kalish and Montague System
                        \ for Monadic Second-Order Logic, showing how to prove
                        \ an instance of the comprehension scheme, using
                        \ a predicate abstraction rule.

                    ^{proofcheck 9 "secondOrder" "render" ":|-: EXAx(F(x) /\\ G(x) <-> X(x))" comprehensionTheorem}

                <div.demo>

                    <p> This is a proof that every relation has an inverse, in
                        \ a system of arbitrarily (finitely) Polyadic
                        \ Second-Order Logic, again making use of a predicate
                        \ abstraction rule.

                    ^{proofcheck 10 "polyadicSecondOrder" "render" ":|-: AX2EY2AxAy(X2(x,y)<->Y2(y,x))" inverseTheorem}


                <div.demo>

                    <p> Here are proofs of axioms 5 and B within natural
                        \ deduction systems for propositional modal logics K5
                        \ and KTB, in the style of Hardegree's #
                        <a href="http://courses.umass.edu/phil511-gmh/MAIN/IHome-1.htm">Modal Logic.
                    <p> These use #
                        <a href="https://github.com/gleachkr/FiraLogic">Fira Logic
                        \ for nicer-looking logical symbols and use guards to
                        \ help visually indicate the scope of each subproof.

                    ^{proofcheck 11 "hardegree5" "fonts guides" ":|-:<>[]P->[]P" axiomFiveTheorem}

                    ^{proofcheck 12 "hardegreeB" "fonts guides" ":|-: <>[]P->P" axiomBTheorem}

                <div.demo>

                    <p> Here's a proof of the Barcan Formula within a naïvely
                        \ quantified system of modal logic, based on the system
                        \ MPL of Hardegree's <em>Modal Logic</em>.

                    ^{proofcheck 13 "hardegreeMPL" "fonts guides" ":|-: Ax[]Fx->[]AxFx" barcanTheorem}

                <div.demo>

                    <p> Carnap also includes a JSON API, making it possible to
                        \ create pure JavaScript GUIs that use Carnap under
                        \ the hood for in-browser proof checking. Here's an example
                        \ of such a GUI, adapted from #
                        <a href="https://the21stcenturymonads.net/forallx/">
                            Kevin Klement's forallx proofchecker
                        \ using P.D. Magnus' #
                        <i>Forall x
                        \ system SL.

                    <div.exercise>
                        <span> example 14
                        <div#klementProof>
                            (W ∨ X), (Y ∨ Z), X → Y, ¬Z ∴ W ∨ Y

            <div#demo-selector>
                <span#demo-left>〈
                <span#demo-num>1
                /
                <span#demo-tot>n
                <span#demo-right>〉

    <section#why>


        <h2>What's Carnap for?

        <p> Carnap is intended for use by educators, students, and researchers
            \ working on logic. Carnap makes it possible for educators to create
            \ interactive exercises and teaching materials, and for students to get
            \ quick and helpful feedback as they learn semantic and syntactic methods
            \ for determining what follows from what. Carnap also enables researchers
            \ interested in unorthodox formal systems to rapidly prototype
            \ proof-checking and semantic tools for computer-assisted logical
            \ investigation.

    <section#name>
        <h2>Why “Carnap”?

        <p> Carnap is named after Rudolf Carnap, the philosopher quoted above.

        <p> Carnap (the philosopher) famously advocated a tolerant and
            \ experimental approach to logic. Carnap (the program) is pluralistic by
            \ design. Inference rules are specified declaratively, making it easy to
            \ add new logics to those already provided for a given language. The
            \ algorithms for checking whether inferences are correct are applicable
            \ to a wide variety of languages, making it easy to introduce new
            \ languages.

        <p> Carnap (the philosopher) also had a lot to say about logical types,
            \ and how ignoring them can leave you with beliefs that don’t work very
            \ well. Carnap (the program) is written in Haskell, a statically-typed
            \ pure functional programming language that uses a theory of logical
            \ types to ensure code correctness.

    <section#how>
        <h2>How does Carnap work?

        <p> Well, it's a little technical. There are a couple of different tricks involved.

        <p>Basically, Haskell's type system makes it possible to represent
           \ different lexical categories as datatypes, to combine these lexical
           \ category datatypes into a larger datatype representing a lexicon (using
           \ something like the method described in #
           \ <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.101.4131">this paper</a>),
           \ and to define a language as the result of applying different
           \ elements of a lexicon to one another in a grammatical way.

        <p>The upshot is that, using Carnap, you can define a language as the
           \ result of snapping together predefined lexical categories. Thanks to
           \ Haskell's typeclasses, your languages will inherit various useful
           \ properties that their constituent lexical categories carry along with
           \ them (for example, languages that contain the lexical category for
           \ Boolean connectives will automatically know how to parse and display
           \ the symbol for “and”, or how to compute the semantic value of
           \ a conjunction from the semantic values of its conjuncts). And, because
           \ of Haskell's static typing and the trick of representing lexical
           \ categories as types, you're guaranteed that any programming mistake
           \ potentially resulting in an ungrammatical expression will be detected
           \ when you try to compile the program.

        <p>By representing a large class of languages uniformly (as the result
            \ of snapping together lexical categories), we also end up being able to
            \ manipulate them uniformly. In particular, we can use entirely generic
            \ algorithms for things like variable substitution, semantic evaluation,
            \ β-normalization, higher-order unification… all the good stuff that
            \ you need in order to, for example, check proofs for correctness using
            \ only a declaration of acceptable inference rules. As a result, we only
            \ need to write code for these algorithms once; we can then automatically
            \ use that code with any language that can be defined in the Carnap
            \ framework.

        <p>So that's the gist of it. If you'd like to learn more about the
            \ details, you can inspect the code, talk to a developer, or read the
            \ documentation.

    <section#usage>
        <h2>How can I use Carnap?

        <p>At the moment, the main application for Carnap is to create
            \ interactive logic webapps<span class="hidden"> like the ones you see
            \ above</span>. Webapps for Carnap can be be written in Haskell, and
            \ translated into JavaScript using the GHCJS compiler. Or, you can write
            \ a front-end in JavaScript and pass proofs to Carnap as JSON for
            \ verification.

        <p>The webapps already written using Carnap should be easy to include
            \ in websites. Since they're compiled down from Haskell to pure
            \ JavaScript, all you have to do is include the relevant JavaScript file,
            \ and indicate in your HTML where you want the interactive widgets to go.
            \ You can even use Carnap without doing any coding at all; Carnap
            \ integrates with John McFarlane's <a href="pandoc.org">pandoc</a>. So
            \ you can transform documents written in pandoc markdown into interactive
            \ websites and lecture slides. In fact, the <a href="@{BookR}">Carnap
            \ Book</a> was written in this way.

        <p>Carnap also powers Kansas State University's <i>Introduction to
            \ Formal Logic</i> and <i>Introduction to Symbolic Logic I</i>, allowing
            \ instructors to write problem sets in pandoc, handling the grading, and
            \ allowing students to build up a repertoire of derived rules and lemmas
            \ that they can use in their work. If you're interested in teaching your
            \ own logic class using Carnap, please don't hesitate to get in touch.

        <p>Other applications (including a command-line tool and a standalone
            \ desktop application) are in the works.

    <section#contributing>
        <h2>How can I get involved?

        <p>If you’d like to support Carnap, please consider starring us on
           \ <a href="https://github.com/gleachkr/Carnap">Github</a>. If you
           \ have suggestions, feature requests, or bug-reports, you can create
           \ an issue on Github. For general questions, or if you'd like to use
           \ Carnap in a class you're teaching, just get in touch on
           \ <a href="https://gitter.im/Carnap-Prover">Gitter</a>
           \ on <a href="irc://irc.freenode.net/carnap">irc</a>
           \ or over <a href="mailto:gleachkr@ksu.edu">email</a>.

        <p>If you’d like to contribute some code to the project—anything from
           \ a new unification algorithm to a CSS tweak or pandoc template—just put
           \ in a pull request!
