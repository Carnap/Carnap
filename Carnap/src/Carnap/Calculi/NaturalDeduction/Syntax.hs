{-#LANGUAGE GADTs, TypeOperators, FlexibleContexts, MultiParamTypeClasses, TypeSynonymInstances, FlexibleInstances, FunctionalDependencies#-}
module Carnap.Calculi.NaturalDeduction.Syntax
where

import Data.Tree
import Data.List (permutations)
import Control.Monad.State
import Carnap.Core.Unification.Unification
import Carnap.Core.Unification.FirstOrder
import Carnap.Core.Unification.ACUI
import Carnap.Core.Data.AbstractSyntaxDataTypes
import Carnap.Core.Data.AbstractSyntaxClasses
import Carnap.Languages.PurePropositional.Syntax
import Carnap.Languages.ClassicalSequent.Syntax
import Carnap.Languages.ClassicalSequent.Parser
import Carnap.Languages.PurePropositional.Parser
--------------------------------------------------------
--1. Data For Natural Deduction
--------------------------------------------------------

class ( FirstOrder (ClassicalSequentOver lex)
      , ACUI (ClassicalSequentOver lex)) => 
        Inference r lex | r -> lex where
        premisesOf :: r -> [ClassicalSequentOver lex Sequent]
        conclusionOf :: r -> ClassicalSequentOver lex Sequent
        --TODO: direct, indirect inferences, template for error messages,
        --etc.

data ProofLine r lex where 
       ProofLine :: Inference r lex => 
            { lineNo  :: Int 
            , content :: ClassicalSequentOver lex Succedent
            , rule    :: [r] } -> ProofLine r lex

type ProofTree r lex = Tree (ProofLine r lex)

type SequentTree lex = Tree (Int, ClassicalSequentOver lex Sequent)

type ProofErrorMessage = String

--Proof skeletons: trees of schematic sequences generated by a tree of
--inference rules. 

--------------------------------------------------------
--2. Transformations
--------------------------------------------------------

--Proof Tree to Sequent Tree
--
-- Proof Tree to proof skeleton

--------------------------------------------------------
--3. Algorithms
--------------------------------------------------------

reduceProofTree :: (Inference r lang, MaybeMonadVar (ClassicalSequentOver lang) (State Int),
        MonadVar (ClassicalSequentOver lang) (State Int)) =>  
        ProofTree r lang -> Either [ProofErrorMessage] (ClassicalSequentOver lang Sequent)
reduceProofTree (Node (ProofLine no cont rule) ts) =  
        do prems <- mapM reduceProofTree ts
           firstRight $ seqFromNode rule prems cont
               -- TODO: label errors with lineNo

data PropLogic = MP | MT | DNE | DNI | DD | AX | CP1 | CP2 | ID1 | ID2 | ID3
               deriving Show

instance Inference PropLogic PurePropLexicon where
    premisesOf MP  = [ GammaV 1 :|-: SS (SeqPhi 1 :->-: SeqPhi 2)
                     , GammaV 2 :|-: SS (SeqPhi 1)
                     ]
    premisesOf MT  = [ GammaV 1 :|-: SS (SeqPhi 1 :->-: SeqPhi 2)
                     , GammaV 2 :|-: SS (SeqNeg $ SeqPhi 2)
                     ]
    premisesOf AX  = []
    premisesOf DD  = [ GammaV 1 :|-: SS (SeqPhi 1) ]
    premisesOf DNE = [ GammaV 1 :|-: SS (SeqNeg $ SeqNeg $ SeqPhi 1) ]
    premisesOf DNI = [ GammaV 1 :|-: SS (SeqPhi 1) ]
    premisesOf CP1 = [ GammaV 1 :+: SA (SeqPhi 1) :|-: SS (SeqPhi 2) ]
    premisesOf CP2 = [ GammaV 1 :|-: SS (SeqPhi 2) ]
    premisesOf ID1 = [ GammaV 1 :+: SA (SeqPhi 1) :|-: SS (SeqPhi 2) 
                     , GammaV 2 :|-: SS (SeqNeg $ SeqPhi 2)
                     ]
    premisesOf ID2 = [ GammaV 1  :|-: SS (SeqPhi 2) 
                     , GammaV 2 :+: SA (SeqPhi 1) :|-: SS (SeqNeg $ SeqPhi 2)
                     ]
    premisesOf ID3 = [ GammaV 1  :|-: SS (SeqPhi 2) 
                     , GammaV 2  :|-: SS (SeqNeg $ SeqPhi 2)
                     ]

    conclusionOf MP  = (GammaV 1 :+: GammaV 2) :|-: SS (SeqPhi 2)
    conclusionOf MT  = (GammaV 1 :+: GammaV 2) :|-: SS (SeqNeg $ SeqPhi 1)
    conclusionOf AX  = SA (SeqPhi 1) :|-: SS (SeqPhi 1)
    conclusionOf DD  = GammaV 1 :|-: SS (SeqPhi 1) 
    conclusionOf DNE = GammaV 1 :|-: SS (SeqPhi 1) 
    conclusionOf DNI = GammaV 1 :|-: SS (SeqNeg $ SeqNeg $ SeqPhi 1) 
    conclusionOf CP1 = GammaV 1 :|-: SS (SeqPhi 1 :->-: SeqPhi 2) 
    conclusionOf CP2 = GammaV 1 :|-: SS (SeqPhi 1 :->-: SeqPhi 2)
    conclusionOf ID1 = GammaV 1 :+: GammaV 2 :|-: SS (SeqNeg $ SeqPhi 1)
    conclusionOf ID2 = GammaV 1 :+: GammaV 2 :|-: SS (SeqNeg $ SeqPhi 1)
    conclusionOf ID3 = GammaV 1 :+: GammaV 2 :|-: SS (SeqNeg $ SeqPhi 1)

firstRight :: [Either a [b]] -> Either [a] b
firstRight xs = case filter isRight xs of
                    [] -> Left $ map (\(Left x) -> x) xs
                    (Right (r:x):rs) -> Right r
    where isRight (Right _) = True
          isRight _ = False

--Given a list of concrete rules and a list of (variable-free) premise sequents, and a (variable-free) 
--conclusion succeedent, return an error or a list of possible (variable-free) correct 
--conclusion sequents
seqFromNode :: (Inference r lang, MaybeMonadVar (ClassicalSequentOver lang) (State Int),
        MonadVar (ClassicalSequentOver lang) (State Int)) =>  
    [r] -> [ClassicalSequentOver lang Sequent] -> ClassicalSequentOver lang Succedent 
      -> [Either ProofErrorMessage [ClassicalSequentOver lang Sequent]]
seqFromNode rules prems conc = do rrule <- rules
                                  rprems <- permutations (premisesOf rrule) 
                                  return $ oneRule rrule rprems
    where oneRule r rp = do if length rp /= length prems 
                                then Left "Wrong number of premises"
                                else Right ""
                            let rconc = conclusionOf r
                            fosub <- fosolve 
                               (zipWith (:=:) 
                                   (map rhs (rconc:rp)) 
                                   (conc:map rhs prems))
                            let subbedrule = map (applySub fosub) rp
                            let subbedconc = applySub fosub rconc
                            acuisubs <- acuisolve 
                               (zipWith (:=:) 
                                   (map lhs subbedrule) 
                                   (map lhs prems))
                            return $ map (\x -> applySub x subbedconc) acuisubs

--A simple check of whether two sequents can be unified
seqUnify s1 s2 = case check of
                     Left _ -> False
                     Right [] -> False
                     Right _ -> True
            where check = do fosub <- fosolve [rhs s1 :=: rhs s2]
                             acuisolve [lhs (applySub fosub s1) :=: lhs (applySub fosub s2)]

fosolve :: (FirstOrder (ClassicalSequentOver lang), MonadVar (ClassicalSequentOver lang) (State Int)) =>  
    [Equation (ClassicalSequentOver lang)] -> Either ProofErrorMessage [Equation (ClassicalSequentOver lang)]
fosolve eqs = case evalState (foUnifySys (const False) eqs) (0 :: Int) of 
                [] -> Left "Unification Error in Rule"
                [s] -> Right s

acuisolve :: (ACUI (ClassicalSequentOver lang), MonadVar (ClassicalSequentOver lang) (State Int)) =>  
    [Equation (ClassicalSequentOver lang)] -> Either ProofErrorMessage [[Equation (ClassicalSequentOver lang)]]
acuisolve eq = 
        case evalState (acuiUnifySys (const False) eq) (0 :: Int) of
          [] -> Left "Unification Error in Assumptions"
          subs -> Right subs

rhs :: ClassicalSequentOver lang Sequent -> ClassicalSequentOver lang Succedent
rhs (x :|-: (Bot :-: y)) = rhs (x :|-: y)
rhs (_ :|-: y) = y 

lhs :: ClassicalSequentOver lang Sequent -> ClassicalSequentOver lang Antecedent
lhs (x :|-: _) = x
