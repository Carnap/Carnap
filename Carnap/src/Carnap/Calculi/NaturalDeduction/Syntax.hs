{-#LANGUAGE GADTs, TypeOperators, FlexibleContexts, MultiParamTypeClasses, TypeSynonymInstances, FlexibleInstances, FunctionalDependencies#-}
module Carnap.Calculi.NaturalDeduction.Syntax
where

import Data.Tree
import Data.List (permutations)
import Carnap.Core.Unification.Unification
--import Carnap.Core.Unification.FirstOrder
import Carnap.Core.Unification.ACUI
import Carnap.Core.Data.AbstractSyntaxDataTypes
import Carnap.Core.Data.AbstractSyntaxClasses
import Carnap.Languages.PurePropositional.Syntax
import Carnap.Languages.ClassicalSequent.Syntax
import Carnap.Languages.ClassicalSequent.Parser
import Carnap.Languages.PurePropositional.Parser
--------------------------------------------------------
--1. Data For Natural Deduction
--------------------------------------------------------

class ( FirstOrder (ClassicalSequentOver lex)
      , ACUI (ClassicalSequentOver lex)) => 
        Inference r lex | r -> lex where
        premisesOf :: r -> [ClassicalSequentOver lex Sequent]
        conclusionOf :: r -> ClassicalSequentOver lex Sequent
        --TODO: direct, indirect inferences, template for error messages,
        --etc.

data ProofLine r lex where 
       ProofLine :: Inference r lex => 
            { lineNo  :: Int 
            , content :: ClassicalSequentOver lex Succedent
            , rule    :: [r] } -> ProofLine r lex

type ProofTree r lex = Tree (ProofLine r lex)

type SequentTree lex = Tree (Int, ClassicalSequentOver lex Sequent)

--Proof skeletons: trees of schematic sequences generated by a tree of
--inference rules. 

--------------------------------------------------------
--2. Transformations
--------------------------------------------------------

--Proof Tree to Sequent Tree
--
-- Proof Tree to proof skeleton
