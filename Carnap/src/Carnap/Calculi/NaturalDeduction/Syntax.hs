{-#LANGUAGE GADTs, KindSignatures, TypeOperators, FlexibleContexts, MultiParamTypeClasses, TypeSynonymInstances, FlexibleInstances, FunctionalDependencies#-}
module Carnap.Calculi.NaturalDeduction.Syntax
where

import Data.Tree
import Data.List (permutations)
import Carnap.Core.Unification.Unification
--import Carnap.Core.Unification.FirstOrder
import Carnap.Core.Unification.ACUI
import Carnap.Core.Data.AbstractSyntaxDataTypes
import Carnap.Core.Data.AbstractSyntaxClasses
import Carnap.Languages.PurePropositional.Syntax
import Carnap.Languages.ClassicalSequent.Syntax
import Carnap.Languages.ClassicalSequent.Parser
import Carnap.Languages.PurePropositional.Parser
import Text.Parsec (parse, Parsec, ParseError, choice, try, string)

--------------------------------------------------------
--1. Data For Natural Deduction
--------------------------------------------------------

data DeductionLine r lex a where
        AssertLine :: 
            { asserted :: FixLang lex a
            , assertRule :: [r]
            , assertDepth :: Int
            , assertDependencies :: [(Int,Int)]
            } -> DeductionLine r lex a
        ShowLine :: 
            { toShow :: FixLang lex a
            , showDepth :: Int
            } -> DeductionLine r lex a
        QedLine :: 
            { closureRule :: [r]
            , closureDepth :: Int
            , closureDependencies :: [(Int,Int)]
            } -> DeductionLine r lex a
        PartialLine ::
            { partialLineFormula :: Maybe (FixLang lex a)
            , partialLineError   :: ParseError
            , partialLineDepth   :: Int
            } -> DeductionLine r lex a
        SeparatorLine ::
            { separatorLineDepth :: Int
            } -> DeductionLine r lex a

depth (AssertLine _ _ dpth _) = dpth
depth (ShowLine _ dpth) = dpth
depth (QedLine _ dpth _) = dpth
depth (PartialLine _ _ dpth) = dpth
depth (SeparatorLine dpth) = dpth

isAssumptionLine (AssertLine _ r _ _) = and (map isAssumption r)
isAssumptionLine _ = False

type Deduction r lex = [DeductionLine r lex (Form Bool)]

type MultiRule r = [r]


data ProofErrorMessage :: ((* -> *) -> * -> *) -> * where
        NoParse :: ParseError -> Int -> ProofErrorMessage lex
        NoUnify :: [[Equation (ClassicalSequentOver lex)]]  -> Int -> ProofErrorMessage lex
        GenericError :: String -> Int -> ProofErrorMessage lex
        NoResult :: Int -> ProofErrorMessage lex --meant for blanks

-- TODO These should be combined into a lens

lineNoOfError (NoParse _ n) = n
lineNoOfError (NoUnify _ n) = n
lineNoOfError (GenericError _ n) = n
lineNoOfError (NoResult n) = n

renumber :: Int -> ProofErrorMessage lex -> ProofErrorMessage lex
renumber m (NoParse x n) = NoParse x m
renumber m (NoUnify x n) = NoUnify x m
renumber m (GenericError s n) = GenericError s m
renumber m (NoResult n) = NoResult m

data ProofLine r lex where 
       ProofLine :: Inference r lex => 
            { lineNo  :: Int 
            , content :: ClassicalSequentOver lex Succedent
            , rule    :: [r] } -> ProofLine r lex

type ProofTree r lex = Tree (ProofLine r lex)

--type PossProofTree r lex = Either (ProofErrorMessage lex) (ProofTree r lex)

type FeedbackLine lex = Either (ProofErrorMessage lex) (ClassicalSequentOver lex Sequent)

data Feedback lex = Feedback { finalresult :: Maybe (ClassicalSequentOver lex Sequent)
                             , lineresults :: [FeedbackLine lex]}

type SequentTree lex = Tree (Int, ClassicalSequentOver lex Sequent)

--Proof skeletons: trees of schematic sequences generated by a tree of
--inference rules. 

--------------------------------------------------------
--2. Typeclasses for natural deduction
--------------------------------------------------------

-- XXX we get indeterminism if we want full generality here, so I leave this
--simple for now.

data IndirectArity = PolyProof --takes an arbitrary number of assertions or subproofs, each ending in one assertion
                   | DoubleProof --takes one subproof ending in two assertions

class ( FirstOrder (ClassicalSequentOver lex)
      , ACUI (ClassicalSequentOver lex)) => 
        Inference r lex | r -> lex where
        premisesOf :: r -> [ClassicalSequentOver lex Sequent]
        conclusionOf :: r -> ClassicalSequentOver lex Sequent
        --restrictions, based on given substitutions
        restriction :: r -> Maybe ([Equation (ClassicalSequentOver lex)] -> Maybe String)
        restriction _ = Nothing
        indirectInference :: r -> Maybe IndirectArity
        indirectInference = const Nothing
        isAssumption :: r -> Bool
        isAssumption = const False
        --TODO: template for error messages, etc.

--------------------------------------------------------
--2. Transformations
--------------------------------------------------------

--Proof Tree to Sequent Tree
--
-- Proof Tree to proof skeleton
